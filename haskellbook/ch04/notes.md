## Anatomy of a data declaration

**Data declaration** = Definition for a datatype.

- Keyword `data`

**Type constructor** = Name of the type (capitalised).

**Data constructor** = Value that inhabits the type it is defined in.

## Numeric Types

All have instances of `Num` typeclass.

**Integral numbers**

- `Int` = Fixed-precision integer.
- `Integer` = Arbitrarily sized integer.

**Fractional numbers**

- `Float` = Single-precision floating point numbers.
- `Double` = Double-precision floating point number.
- `Rational` = Fractional number representing a ratio of 2 integers.
  - Arbitrarily precise
  - `Integer` numerator
  - `Integer` denominator
- `Scientific` = Space efficient _almost_ arbitrarily precise scientific number.
- Provided by library https://hackage.haskell.org/package/scientific
  - `Integer` coefficient
  - `Int` exponent

`Num` is a _superclass_ of `Fractional`

- `Fractional` typeclass requires types to already have an instance of `Num` typeclass.
- Functions from the `Num` typeclass can be used with `Fractional` numbers, but functions from the `Fractional` typeclass cannot be use with all types having a `Num` instance.

`/=` = Not equal to

## Definitions

- **Tuple** = ordered grouping of values.
  - Zero tuple = _unit_: `()`
  - Express an **anonymous product**
- **Typeclass** = Set of operations defined w.r.t a _polymorphic_ type.
  - Unique pairings of class and concrete instance
    - A type _a_ can have **only one** instance of `Eq`
- **Data constructor** = Create values that inhabit a given type.
  - _Nullary_ data constructor = constant value i.e. `Bar` in `data Foo = Bar`
- **Type constructor** = Generated by data declarations to denote their type.
  - **Not values**
    - Can only be used in type signatures
- **Data declaration** = Define new datatypes w/ `data` keyword.
  - _Always_ create new type constructors
  - _May or may not_ create new data constructors
- **Polymorphism** = Use of values which may inhabit multiple types.
  - _Parametric polymorphism_ = Handle values _identically_ without depending on the type i.e. does not use any type-specific knowledge and can therefore take any type.
    - e.g. `id` function: `id :: a -> a`
  - _Constrained/bounded polymorphism_ = Set of valid types is constrained by the existence of typeclasaes.
    - e.g. `+` is constrained to the `Num` typeclass: `Num a => a -> a -> a`
