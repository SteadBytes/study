# 1.2 The Concept of Data Type

Within this book:

1. Data type = set of possible values
   - Constants, assumed by variable or expression, generated by operator or function
2. Type of a value can be derived _without_ execution
   - Derived from it's form or declaration
3. Operators & functions both expect arguments and yield results of a _fixed_ type
   - Language rules determine result types for operators accepting multiple types i.e. `+` (int and real)

Compilers use above rules to determine the legality of program constructs.

Appropriate composition of _data_ is equally fundamental and essential as the composition of _operations_.

Operators:

- Equality `x == y`
- Assignment `x := y`
- _Transfer_ -> mapping data types to other data types
  - Constructors
  - Selectors

# 1.3 Primitive Data Types

## Enumeration types

- Unstructured
- Used when numerical properties are _not_ involved, but an integer represents a _choice_ from some set of alternatives

Defines set of all possible values for type `T`:

```
type T = (c1, c2, ..., cn)
```

Cardinality:

```
card(T) = n
```

Values used as _constants_ throughout the program.

**Ordered** enumeration:

- `succ(x)` and `pred(x)` generate the successor and predecessor values in the enumeration of their argument `x`
- Ordering of values of `T` defined by `(ci < cj) === (i < j)`

# 1.4 Standard Primitive Types

Built-in on most computers- `integer, Boolean, char, real` e.t.c

- `integer` -> _exact_ operations
  - Subset of **whole numbers**
- `real` -> inaccurate operations
  - Subset of **real numbers**
  - Within limits of round-off errors from computation on a finite number of digits -> distinction from `integer` required

# 1.5 Subrange Types

Constrain values of a type to within a specific _interval_

```
type T = min..max

type letter 'A'..'Z'
type digit '0'..'9'
```

# 1.6 The Array Structure

- _Homogeneous_ structure
  - Components all of the same type - _base type_
- Random access structure
  - Any component can be selected at random using the _index_
- _index type_ = type of the value used as an index

Array type `T` with base type `T0` and index type `I`:

```
type T = array[I] of T0
```

Conceptually, selective updates of a single component causes the **entire composite value** to change (page 12)

- Despite only a single component value changing
- This is embodied in many functional languages where data structures are _immutable_ i.e. Haskell, Clojure - changing a single component value produces a new, separate composite value.

_Loop invariant_ = condition that is true before and after each iteration in a loop - in the following code, loop invariant = `a[j] != x, for j = 1...i - 1`:

```
// find least index i of component with value x
var a: array[1..N+1] of T;
i := 0; a[N+1] := x;
repeat i:= i+1 until a[i] == x;
if i > N then "there is no such element in a"
```

# 1.7 The Record Structure

Compound type - _cartesian product_ of its constituent types.

```
type T = record s1: T1;
                s2: T2;
                  ...
                sn: Tn;
         end

cardinality(T) = cardinality(T1)*...*cardinality(Tn)
```

# 1.8 Variants of Record Structures

Consider multiple types as _variants_ of the same type

Identify using a _type discriminator_ or _tag_ field

```
type Coordinate =
    record case kind: (Cartesian, polar) of // kind is the tag field
                Cartesian: (x, y: real);
                polar: (r: real; phi: real)
    end
```

Set of values is the _union_ of the constituent types.

In general:

```
type T =
    record s1: T1;...;Sn-1:Tn-1;
        case sn: Tn of
        c1: (s1,1: T1,1;...;s1,n1:T1,n1);
                   .............
        cm: (sm,1: Tm,1;...;sm,nm: Tm,nm)
```

- s<sub>i</sub> and s<sub>ij</sub> = selector names of components
- T<sub>i</sub> and T<sub>ij</sub> = types of components
- s<sub>n</sub> = name of discriminating tag field with type T<sub>n</sub>
- c<sub>1</sub>...c<sub>m</sub> = values of scalar type T<sub>n</sub>

# 1.9 The Set Structure

```
type T = set of T0
```

- Possible values of variable _x_ of type _T_ are the sets of elements of T<sub>0</sub>
- Type of T = powerset of its base type T<sub>0</sub>

```
cardinality(T) = 2^cardinality(T0)
```

- Each element of T<sub>0</sub> has binary cardinality - it's either in the set or not in the set
- Elements of T<sub>0</sub> are independent
- Base type should be finite, with a small cardinality for an efficient set implementation

Set operators:

```
* -> set intersection (set multiplication)
+ -> set union (set addition)
- -> set difference
in -> set membership
```

Precedence:

```
r * s + t = (r * s) + t
r - s * t = r - (s * t)
r - s + t = (r - s) + t
x in s + t = x in (s + t)
```

# 1.10 Representation of Array, Record and Set Structures

Mapping of abstract data structures into a _computer store_.

- Allocating

_Computer store_ = arrays of _words_ (individual storage cells):

- `var store: array[address] of word`
  - addresses = indices of words
- First approximation definition (more complex in reality)

Cardinality of `address` and `word` vary between computers

_wordsize_ = number of bits in a storage cell = logarithm of `cardinality(word)`

## 1.10.1 Representation of Arrays

Mapping of abstract array onto computer store

- Array components type _T_
- Store components type _word_

Linear mapping function for address (store index) _i_ of *j*th array component:

```
i = i0 + j * s
```

- _i<sub>0</sub>_ = address of first component
- _s_ = number of words in a component

_Padding_ = Rounding up _s_ to the next integer _[s]_, when _s_ is not a whole number

- Array occupies _[s]_ words
- _[s]_ - _s_ = unused words

_Storage utilisation factor_ = _u_ = ratio of required storage to amount of storage actually used:

```
u = s/s' = s/[s]
```

Compilers always use padding automatically

- No padding may mean inefficient partial word access
  - Compiled code will expand to make up for this, counteracting the gain in storage utilisation by not padding

_Packing_ = putting more than one array component into each word

- Can be used when `s <= 0.5`
- Increases storage utilisation factor:

  ```
  u = n*s / [n*s]
  ```

Access to *i*th component of a packed array:

```
j = i div n
k = i mod n = i-j*n
```

- _j_ = word address containing the component
- _k_ = position of component within word _j_
- Decrease in access efficiency due to additional computation

## 1.10.2 Representation of Record Structures

```
ki = s1 + s2 + s2 + ... + si-1
```

- _k<sub>i</sub>_ = component/field offset
  - Address of a component _r<sub>i</sub>_ relative to the origin address of the record _r_
- _s<sub>j</sub>_ = size of the *j*th component (in words)

Record components are only _selectable_ by **fixed identifiers**

- Too general for a linear function to compute offset addresses as is the case for arrays
  - Components can be of different types -> different sizes in store
- Offsets are _known_ at compile time -> greater efficiency of field access

Components can be _packed_, similar to arrays, to allow multiple components to be stored within a single word

- Much smaller decrease in access efficiency than when packing arrays as the offsets are known at compile time

## 1.10.3 Representation of Sets

Represented in store by the **characteristic function** _C(s)_

- Array of _logical_ values
- _ith_ component specifies presence or absence of value _i_ in the set
- Size of array determined by set types cardinality:
  ```
  C(si) = (i in s)
  ```

Example:

```
 // set of small integers
s = [1, 4, 8, 9]

// representation in store
C(s) = (FTFFTFFFTT)
```

- Assuming the base type of _s_ = integer subrange `0..9`

Sequence of logical values represented as a _bitstring_:

```
  +-------------------+
s |0 1 0 0 1 0 0 0 1 1|
  +-------------------+
   0 1 2 ...         9
```

Implement set operations using elementary logical operations:

```
i in (x + y) === (i in x) ∨ (i in y)
i in (x * y) === (i in x) ∧ (i in y)
i in (x - y) === (i in x) ∧ ¬(i in y)
```

Logical operations operate concurrently on all bits of a word

- Testing for membership can be done using a single shift and (sign) bit test operation
- Set structure should be use only for small base types

# 1.11 The Sequential File Structure

## Sequences

**Infinite cardinality**

Sequence base type _T<sub>0</sub>_ = empty sequence _or_ concatenation of sequence (with same base type) with a value of type _T<sub>0</sub>_

- _<>_ = empty sequence
- _<x<sub>0</sub>>_ = singleton sequence
- If _x = <x<sub>1</sub>, ..., x<sub>m</sub>>_ and _y = <y<sub>1</sub>, ..., y<sub>m</sub>>_:
  - _x & y = <x<sub>1</sub>, ..., x<sub>m</sub>, y<sub>1</sub>, ..., y<sub>m</sub>>_
  - **Concatenation** of _x_ and _y_
- If _x = <x<sub>1</sub>, ..., x<sub>m</sub>>_ is a non-empty sequence:
  - _first(x) = x<sub>1</sub>_
  - First element of _x_
- If _x = <x<sub>1</sub>, ..., x<sub>m</sub>>_ is a non-empty sequence:
  - _rest(x) = \_<x<sub>2</sub>, ..., x<sub>m</sub>>_
  - Sequence _x_ **without** first component
- _<first(x)> & rest(x) === x_
  - Invariant relation

## The Sequential File (File)

```
type T = file of T0
```

- File of type T consists of 0 or more components of type T<sub></sub>

Sequence components accessed via _file position_, expressed by invariant:

- _x === x<sub>L</sub> & x<sub>R</sub>_
  - _x_ = file
  - _x<sub>L</sub>_ = portion of file to left of current position
  - _x<sub>R</sub>_ = portion of file to right of current position
- Changed by file operators
  - To next component or to first of the sequence

At any time only a single, specific component of sequence is immediately accessible.

Construction & scanning of file are distinct operations

- Cannot be mixed in arbitrary order - i.e. reading before constructing does not produce the same result as constructing before reading

- Construct file via **repeatedly appending** components to the end
- Scan file via sequential scan

File therefore has **two states**:

- Being constructed (written)
- Being scanned (read)

Strict sequential access allows details of data transfer to be hidden from the programmer

- i.e. buffering

## 1.11.1 Elementary File Operators

For a _buffered_ implementation with file _x_ and buffer _x↑_:

- _eof(x) === x<sub>R</sub>> = < >_ = **end of file** predicate
  - Portion of file to the right of the current position is empty -> no more components remaining to be read
- _rewrite(x)_ = constructing empty sequence
  - _x := < >_
  - Overwrite _x_ and initiate construction of new sequence
- _put(x)_ = extending sequence
  - _x := x & <x↑>_
  - Append value _<x↑>_ to _x_
- _reset(x)_ = initiate reading sequence
  - Simultaneous assignments:
    - _x<sub>L</sub> := < >_
    - _x<sub>R</sub> := x_
    - _x↑ := first(x)_
- _get(x)_ = read next sequence component
  - Simultaneous assignments:
    - _x<sub>L</sub> := x<sub>L</sub> & <first(x<sub>R</sub>)>_
    - _x<sub>R</sub> := rest(x<sub>r</sub>)_
    - _x↑ := first(rest(x<sub>r</sub>))_
  - _eof(x)_ **must** be false
- _read(x, v)_ = _v := x↑; get(x)_
  - _v_ = a variable of file component type _T<sub>0</sub>_
  - IFF _¬eof(x)_
- _write(x, e)_ = _x↑ := e; put(x)_
  - _e_ = expression of file of component type _T<sub>0</sub>_
  - IFF _eof(x)_

_read_ and _write_ combine the operation of advancing file position (_get_/_put_) with access to the buffer.

- Allows programmer to ignore existence of the buffer

_first(s)_ only defined if _s != < >_

- Can't take _first_ of an empty sequence

## 1.11.2 Files With Substructure

File of type _T_ represented as a sequence of components (file of files):

- _T = file of T'_
  - _T'_ = type of **substructures** within file
- _T' = file of U_
  - _U_ = type of ultimate components of file

**Multilevel** file:

- Constructed with partitioning to an arbitrary depth of nesting
- Type _T<sub>n</sub>_ defined by recursive relation:
  - _T<sub>i</sub> = file of T<sub>i-1</sub>, i = 1...n_
  - _T<sub>0</sub> = U_
- Component of type _T<sub>i</sub>_ = **segment** of level _i_
- i.e. book with chapters, sections, paragraphs & lines
  - Each a nested _level of segmentation_

### Indexed Files

Indexable table maintained in primary store

- Contains locations within a file where segments begin
- Used to address segments of the file directly
  - Avoid full sequential scan

Writing still takes place _sequentially_ at the end of the file

- Useful for read-heavy applications, where changes are infrequent
- Extend or recopy & update entire file to make changes

Reading/Inspection is _fast_ due to 'direct' access via the index table
